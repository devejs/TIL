# Constructor

## 생성자를 쓰는 이유
가장 큰 이유는 객체(인스턴스) 초기화로, 어떤 객체가 생성될 때 멤버 변수를 초기화해줌으로써 그 **객체의 유효성을 보장**한다.   
일일이 멤버 변수에 접근하여 초기화 하는 경우, 번거롭기도 하거니와 private로 설정된 변수가 있다면 public인 setter 함수를 써야만 초기화가 가능하다.   

> 번외: 초기화 리스트   
생성자 호출과 동시에 멤버 변수들을 초기화 해주는 문법   
함수 본체는 비어있되 생성자 이름 뒤에 초기화 값을 준다   
`(생성자 이름) : var1(arg1), var2(arg2) {}`   
<br>
**초기화 리스트를 써야 하는 이유**   
-> 생성과 초기화를 *동시*에 한다!   
일반적인 생성자에서의 초기화에서는 먼저 생성하고, 초기화는 나중에 되기 때문에 비효율적임. 또한, 상수와 레퍼런스는 생성과 동시에 초기화 되어야 하기 때문에 생성자에서 초기화할 경우 컴파일 에러가 남



## 생성자 종류
1. 기본 생성자(default constructor)
    - 객체 생성시 자동으로 호출되는 함수
2. 복사 생성자
3. 이동 생성자

### 복사 생성자
```C++
// 정의
T(const T& a);
```
어떤 `T` 객체의 인스턴스 `a`를 상수 레퍼런스(`const &`)로 받는다.   
-> const인 이유: 복사 생성자 내부에서 값을 변경하지 못하고 받아 오기만 할 수 있음
```C++
class Example { ... }

Example ex1;
// 복사 생성자가 호출되는 경우
Example ex2(ex1);
Example ex3 = ex2; // 객체 생성시에 대입하는 연산에만 해당
/*
// 아래 연산과는 완전히 다르다
Example ex3;
ex3 = ex2;
*/
```
- 디폴트 복사 생성자   
    일반 디폴트 생성자와 다르게 대응되는 원소들을 1 대 1 복사해줌(얕은 복사)   
    > 문제가 되는 경우:   
    멤버 변수에 동적 할당 메모리가 있을 때, 디폴트 복사 생성자는 얕은 복사만 하게 되므로 같은 메모리를 가리키는 포인터가 두 개 생성되게 되고, 이 자체가 문제가 되지는 않지만 해당 인스턴스가 소멸될 때(소멸자) 동적 할당된 메모리를 해제해주면서 이미 해제한 메모리에 접근해서 해제하려고 하면서 런타임 오류 발생

#### 깊은 복사와 얕은 복사
- 깊은 복사: 메모리를 새로 할당해서 내용 복사
- 얕은 복사: 단순히 값 대입

#### 복사 생략


### 이동 생성자


### move sementics
`(C++ 11~)`
```c++
// 정의
#include <utility>

std::move();
```




### Reference
- [모두의 코드: 우측값 레퍼런스](https://modoocode.com/227)



======================================================
###### 230526 TIL