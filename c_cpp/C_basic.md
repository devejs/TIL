# C_basic

### Endian
메모리에 데이터를 배열하는 방법
- 메모리에 있는 데이터를 CPU 에서 연산하기 위해 읽어올 때, 어떤 순서로 읽어올 것인가?
- Big Endian: 사람이 인식하는 순서 그대로 메모리에 배열
    - 큰 숫자가 앞에 오는 방식(주소가 커질수록 작은 숫자가 배열됨)
    - 네트워크에서 주소 쓰는 방식
    - ex. 0x00112233 -> 00 11 22 33
- Little Endian: Big Endian 의 반대
    - 큰 숫자가 더 큰 주소에 배열되는 방식
    - Intel 계열 CPU 채택
    - ex. 0x00112233 -> 33 22 11 00
    - 장점: 메모리에 저장된 값의 하위 바이트들만 사용할 때 별도의 계산이 필요 없음
- Middle Endian: Big/Little 두 경우에 속하지 않거나 둘을 모두 지원하는 것
    - ex) 32비트 정수가 2바이트 단위로는 빅 엔디언이고 그 안에서 1바이트 단위로는 리틀 엔디언인 경우
- 비트 순서
    - 보통 메모리의 접근은 바이트 단위로 이루어지기 때문에 비트 단위의 접근에는 별도의 연산 과정이 필요함
        - 최상위 비트 우선: 최상위 비트(MSB)부터 채우는 것
        - 최하위 비트 우선: 최하위 비트(LSB)부터 채우는 것
    - 비트 필드: C 언어 구조체에서 바이트보다 더 작은 비트 단위로 구조체 멤버를 할당하여 사용
        ```C
        struct Flags {
            unsigned int a : 1;     // a는 1비트 크기
            unsigned int b : 3;     // b는 3비트 크기
            unsigned int c : 7;     // c는 7비트 크기
        };
        ```

### 실수형과 부동소수점
- 실수형
    - float: 단정도, 32bit; 해상도가 낮아 최근에는 사용하지 않는 추세
        - 유효 자릿수: 소수점 이하 6자리
    - double: 배정도, 634bit
        - 유효 자릿수: 소수점 이하 15자리
    - long double: 특수정도, 79bit; 거의 사용하지 않음

- 부동 소수점
    - 무한소수의 경우, 무한정으로 그 값을 저장할 수 없으므로 필연적으로 오차가 생김 -> **비교 연산시 오류가 발생할 수 있음**
    - 정밀도: 근삿값을 사용하여 실수값을 표기함; 어디까지 저장하느냐에 따라 정밀도가 달라짐
    - IEEE754: 컴퓨터에서 부동소수점을 표현하는 가장 널리 쓰이는 표준
        - 32비트 단정밀도(single-precision)
        - 64비트 배정밀도(double-precision)
        - 43비트 이상의 확장 단정밀도(거의 쓰이지 않음)
        - 79비트 이상의 확장 배정밀도(일반적으로 80비트로 구현됨)

- 예시 (123.125F의 메모리 구조)
    - `F`가 붙었으므로 float (안 붙으면 double 로 처리됨)
        - float의 메모리 구조
            - 1bit: 부호
            - 8bit: 지수
            - 23bit: 가수
    - 실수 계산
        1. 양수이므로 sign bit: 0
        2. 지수: 정수부분 2진수 변환
            - 123을 2진수 변환하면 1111011
        3. 가수: 2를 곱해 정수 값이 있으면 1
            - 0.125에 2를 계속 곱하면 .001
        4. 정규화
            - 1111011.001 값을 정규화시키면
                - 1.111011001 -> 지수가 6
                - 지수 + bias 기준값(단정도형 127) = 133 -> 10000101
            - 1.111011001 의 가수는 .111011001; 오른쪽에 0을 채워 23bit 만들기
        5. 최종: 부호+지수+가수
            - 01000010111101100100000000000000 -> 42 F6 40 00
        6. Little Endian 적용: `00 40 F6 42`

### 문자열 상수
> 문자열의 본질
> C언어에서 문자열이란 -> 배열; 즉, 본질은 메모리
> 즉, 문자열은 메모리에 저장된 실수형 정수(문자)의 Stream

> 문자열은 수정할 수 있는가?
> 배열이므로, 수정이 가능함. `const` 등의 문제는 아래에.

> 문자열은 어디에 저장되는가?
> 결론부터 말하면, 메모리 Data 영역의 Static: R-- 공간.
> 즉, 문자열 상수들은 실행 바이너리 파일 안에 들어가서 실행될 때 영역이 할당됨
> 
> (리버싱: 내부 구조를 알 수 없을 때, 외부의 동일한 기능을 구현하기 위해 내부를 뜯어 분석하는 행위)

- 메모리에 접근한다는 것은: **RWX**. 읽거나 쓰거나 실행하는 것
    - 상수화: **R(Read)** 만 가능하게 하겠다

```C
#include <stdio.h>

int main()
{
    char* str = "HelloWorld!\n";    // 1
    printf(str);                    // 출력: HelloWorld!
    printf("HelloWorld!\n");        // 출력: HelloWorld! 2

    str = "new string";
    printf(str);                    // 출력: new string

    return 0;
}
```
1. `const char[]` 자료형인 "HelloWorld!\n" 라는 문자열이 메모리에 있고, 이 문자열 첫 글자의 주소를 str 에다 할당함
    - `const`이므로 문자열 상수. 그러나 코드 레벨에서 상수인 거고, 메모리에 올라간 배열인 이상 수정은 가능함
    - 그렇다면 이 배열(문자열)은 어디에 저장되는가?
2. 1번의 "HelloWorld!\n" 와 동일한 문자열이다. 그럼 같은 주소를 공유할까? 아니면 다른 주소를 공유할까?
    - 이 두 문자열은 같은 주소를 공유한다.
    - 바이너리에서 이 메모리 위치를 찾아 억지로 수정할 경우, 두 줄은 바뀐 대로 동일하게 출력한다.

#### 메모리 구조
- Data
    - 할당 시점이 Runtime시 (프로그램 실행시)
        - Heap: malloc ~ 동적 할당
        - Stack: 자동 변수(기본적으로 코드 블록 안에 선언된 모든 변수; 정적 변수 제외) 
    - 할당 시점이 Compile시 (Compile 시 계산되어 빌드 타임에 코드 속으로 들어감)
        - Static
            - **R--** : 여기에 문자열 저장
            - RW- : Static

### 컴파일러
#### 코드 시점
1. **Compile time**: 코드 작성 -> 번역 -> 기계어 변환 ==> 목적 파일 생성
    - 문법적인 error 주로 발생
    - 전처리: 헤더 파일 포함, 매크로 확장
        - gcc는 `cpp` 라는 전처리기 사용
    - 컴파일: C언어 코드가 `ccl`에 의해 어셈블리어로 변환
        - 전단부(Front-end): 언어 종속적인 부분 처리(어휘, 구문, 의미 분석)
        - 중단부(Middle-end): SSA 기반으로 최적화 수행(프로그램 수행 속도 향상으로 성능 향상)
        - 후단부(Back-end): RTS로 아키텍처 최적화 수행(더 효율적인 명령어로 대체해서 성능 향상)
2. Link time: 여러 조각 파일들을 하나로 묶어 실행 파일 생성 ==> 런타임 바이너리 생성
- Compile time, Link time 을 묶어 Build time으로 부르기도 함

3. Run time: 실행 파일 실행시 
    - error 발생시 디버깅이 어려움; 환경(OS 등)에 영향이 큼
        - 실행 -> Memory 이슈... (Stack 내용 dump 떠서 분석한다거나)
        - 대부분 프로그램이 멀티 스레딩 환경이므로 동시성 이슈도 고려

#### 컴파일러 구성 요소
- Front-end
    - 어휘 분석기(Lexical analyzer): Token
        - 문자열 형태로 존재하는 소스 코드를 의미 있는 문자 혹은 문자열 조각(토큰)으로 변환
        - 예약어, 상수, 변수, 연산자 등
        - 이 때 자르는 기준(delimiter)은 빈칸(space, \n, \t 등), 세미콜론 등 어느 것이든 될 수 있음
            - 자른다/tokenize 의 의미는 단순히 delimiter 기준으로 `strtok` 하는 것일 수도 있지만, delimiter 기준으로 문자열의 끝에 null(\0) 을 추가해서 나누는 것일 수도 있음
        - 정규 표현식
        ```C
        // human code
        int main()
        {
            int a;
            a = 3+4;
            printf("a is %d\n", a);

            return 0;
        }

        // computer code
        int main(){int a;a = 3+4;printf("a is %d\n", a);return 0;}
        // parse computer code with delimiter, and then analyze syntax
        ```
    - 구문 분석기(Syntax analyzer): Syntax tree
        - 각 토큰을 구문 트리(Syntax tree)로 변환하며 이 과정에서 문법 오류 검출
        - 추상 구문 트리(AST)
            - 트리의 각 노드는 소스 코드에서 발생되는 구조를 나타냄
            * 참고 사이트: astexplorer.net
    - 의미 분석기(Semntic analyzer): Intermediate Representation
- Back-end
    - 코드 생성기(Code generator): Assemble code + Optimization
        - IR로부터 어셈블리어 등 기계어에 대응될 수 있는 쉬운 명령어 연속(집합)으로 변환
            - function prologue: push stack, ...
            - function epilogue: pop stack, ...
        - 기계어 변환 전 불필요한 코드 제거 등의 최적화 작업
            - 릴리즈 빌드시 function prologue/epilogue 부분을 포함하여 컴파일러 최적화 => 내가 생각하는 **많은 연산이 생략됨**
            1. 불필요한 연산 제거
                - 변수에 대한 의존 관계 분석
                    ```C
                    int a;
                    a = 3+4;
                    some_func(a);
                    // some_func(7); 로 축약 가능
                    /*
                        위 코드에서 a를 역추적 했을 때, a가 쓰이는 곳을 파악해서 그 코드가 정말 필요한지 분석하여 필요 없는 코드는 과감히 제거하고 축약해버림
                     */ 
                    ```
                - 불필요한 상수 연산을 결과로 대체
                - 반복문 내부 불필요한 코드 제거
                    - 예전에는 반복문 내 변수 선언을 지양하였으나, 요즘에는 컴파일러 성능이 좋아져서 상관 없다고 보는 편
                    - 컴파일러가 어마어마하게 코드 축약을 한다
            2. 함수 호출이 필요 없도록 inline화 (함수 호출에 대한 overload 제거)
                - 언어 문법으로 존재하지만 보통은 컴파일러가 자동으로 처리
        - 그럼 뭐가 좋은 코드인가?
            - 컴파일러가 대부분 자동으로 처리해준다면, 컴파일러가 더 쉽게 처리할 수 있도록 지원해주는 코드
                - 나는 오히려 컴파일러가 다 해주니 내가 최적화를 할 필요가 없다고 생각했는데
            - 즉, 상수화를 잘 해라
                - 그런 부분에서는 Pointer 가 오히려 모순적일 수 있음
                - 포인터 변수 자체는 상수화를 하더라도 포인터가 가리키는 주소가 중요한데 그 주소는 어디서 참조될지 모르기 때문에 상수화가 어려움<br>
                -> 이 것들을 전부 다 일일이 고려해서 코드를 짤 수는 없지만, 최소한 컴파일러가 어떤 역할을 하고 내가 어떻게 코드를 짜야 좋은 지를 항상 고민해 볼 것.
    - 어셈블러(Assembler): Machine code

#### Reference
- [독하게 되새기는 C 프로그래밍](https://www.inflearn.com/course/독하게-되새기는-c프로그래밍/dashboard)
- [IEEE754](https://ko.wikipedia.org/wiki/IEEE_754)
- [추상 구문 트리](https://ko.wikipedia.org/wiki/추상_구문_트리)

======================================================
###### 231024 TIL
###### 231027 TIL
###### 231028 TIL
###### 231029 TIL
###### 231103 TIL
###### 231104 TIL