# C_basic
## Contents
- [Endian](#Endian)
- [실수형과 부동소수점](#실수형과-부동소수점)
- [문자열 상수](#문자열-상수)
- [컴파일러](#컴파일러)
- [함수](#함수)
- [파일 입출력](#파일-입출력)


### Endian
메모리에 데이터를 배열하는 방법
- 메모리에 있는 데이터를 CPU 에서 연산하기 위해 읽어올 때, 어떤 순서로 읽어올 것인가?
- Big Endian: 사람이 인식하는 순서 그대로 메모리에 배열
    - 큰 숫자가 앞에 오는 방식(주소가 커질수록 작은 숫자가 배열됨)
    - 네트워크에서 주소 쓰는 방식
    - ex. 0x00112233 -> 00 11 22 33
- Little Endian: Big Endian 의 반대
    - 큰 숫자가 더 큰 주소에 배열되는 방식
    - Intel 계열 CPU 채택
    - ex. 0x00112233 -> 33 22 11 00
    - 장점: 메모리에 저장된 값의 하위 바이트들만 사용할 때 별도의 계산이 필요 없음
- Middle Endian: Big/Little 두 경우에 속하지 않거나 둘을 모두 지원하는 것
    - ex) 32비트 정수가 2바이트 단위로는 빅 엔디언이고 그 안에서 1바이트 단위로는 리틀 엔디언인 경우
- 비트 순서
    - 보통 메모리의 접근은 바이트 단위로 이루어지기 때문에 비트 단위의 접근에는 별도의 연산 과정이 필요함
        - 최상위 비트 우선: 최상위 비트(MSB)부터 채우는 것
        - 최하위 비트 우선: 최하위 비트(LSB)부터 채우는 것
    - 비트 필드: C 언어 구조체에서 바이트보다 더 작은 비트 단위로 구조체 멤버를 할당하여 사용
        ```C
        struct Flags {
            unsigned int a : 1;     // a는 1비트 크기
            unsigned int b : 3;     // b는 3비트 크기
            unsigned int c : 7;     // c는 7비트 크기
        };
        ```

### 실수형과 부동소수점
- 실수형
    - float: 단정도, 32bit; 해상도가 낮아 최근에는 사용하지 않는 추세
        - 유효 자릿수: 소수점 이하 6자리
    - double: 배정도, 634bit
        - 유효 자릿수: 소수점 이하 15자리
    - long double: 특수정도, 79bit; 거의 사용하지 않음

- 부동 소수점
    - 무한소수의 경우, 무한정으로 그 값을 저장할 수 없으므로 필연적으로 오차가 생김 -> **비교 연산시 오류가 발생할 수 있음**
    - 정밀도: 근삿값을 사용하여 실수값을 표기함; 어디까지 저장하느냐에 따라 정밀도가 달라짐
    - IEEE754: 컴퓨터에서 부동소수점을 표현하는 가장 널리 쓰이는 표준
        - 32비트 단정밀도(single-precision)
        - 64비트 배정밀도(double-precision)
        - 43비트 이상의 확장 단정밀도(거의 쓰이지 않음)
        - 79비트 이상의 확장 배정밀도(일반적으로 80비트로 구현됨)

- 예시 (123.125F의 메모리 구조)
    - `F`가 붙었으므로 float (안 붙으면 double 로 처리됨)
        - float의 메모리 구조
            - 1bit: 부호
            - 8bit: 지수
            - 23bit: 가수
    - 실수 계산
        1. 양수이므로 sign bit: 0
        2. 지수: 정수부분 2진수 변환
            - 123을 2진수 변환하면 1111011
        3. 가수: 2를 곱해 정수 값이 있으면 1
            - 0.125에 2를 계속 곱하면 .001
        4. 정규화
            - 1111011.001 값을 정규화시키면
                - 1.111011001 -> 지수가 6
                - 지수 + bias 기준값(단정도형 127) = 133 -> 10000101
            - 1.111011001 의 가수는 .111011001; 오른쪽에 0을 채워 23bit 만들기
        5. 최종: 부호+지수+가수
            - 01000010111101100100000000000000 -> 42 F6 40 00
        6. Little Endian 적용: `00 40 F6 42`

### 문자열 상수
> 문자열의 본질
> C언어에서 문자열이란 -> 배열; 즉, 본질은 메모리
> 즉, 문자열은 메모리에 저장된 실수형 정수(문자)의 Stream

> 문자열은 수정할 수 있는가?
> 배열이므로, 수정이 가능함. `const` 등의 문제는 아래에.

> 문자열은 어디에 저장되는가?
> 결론부터 말하면, 메모리 Data 영역의 Static: R-- 공간.
> 즉, 문자열 상수들은 실행 바이너리 파일 안에 들어가서 실행될 때 영역이 할당됨
> 
> (리버싱: 내부 구조를 알 수 없을 때, 외부의 동일한 기능을 구현하기 위해 내부를 뜯어 분석하는 행위)

- 메모리에 접근한다는 것은: **RWX**. 읽거나 쓰거나 실행하는 것
    - 상수화: **R(Read)** 만 가능하게 하겠다

```C
#include <stdio.h>

int main()
{
    char* str = "HelloWorld!\n";    // 1
    printf(str);                    // 출력: HelloWorld!
    printf("HelloWorld!\n");        // 출력: HelloWorld! 2

    str = "new string";
    printf(str);                    // 출력: new string

    return 0;
}
```
1. `const char[]` 자료형인 "HelloWorld!\n" 라는 문자열이 메모리에 있고, 이 문자열 첫 글자의 주소를 str 에다 할당함
    - `const`이므로 문자열 상수. 그러나 코드 레벨에서 상수인 거고, 메모리에 올라간 배열인 이상 수정은 가능함
    - 그렇다면 이 배열(문자열)은 어디에 저장되는가?
2. 1번의 "HelloWorld!\n" 와 동일한 문자열이다. 그럼 같은 주소를 공유할까? 아니면 다른 주소를 공유할까?
    - 이 두 문자열은 같은 주소를 공유한다.
    - 바이너리에서 이 메모리 위치를 찾아 억지로 수정할 경우, 두 줄은 바뀐 대로 동일하게 출력한다.

#### 메모리 구조
- Data
    - 할당 시점이 Runtime시 (프로그램 실행시)
        - Heap: malloc ~ 동적 할당
        - Stack: 자동 변수(기본적으로 코드 블록 안에 선언된 모든 변수; 정적 변수 제외) 
    - 할당 시점이 Compile시 (Compile 시 계산되어 빌드 타임에 코드 속으로 들어감)
        - Static
            - **R--** : 여기에 문자열 저장
            - RW- : Static

### 컴파일러
#### 코드 시점
1. **Compile time**: 코드 작성 -> 번역 -> 기계어 변환 ==> 목적 파일 생성
    - 문법적인 error 주로 발생
    - 전처리: 헤더 파일 포함, 매크로 확장
        - gcc는 `cpp` 라는 전처리기 사용
    - 컴파일: C언어 코드가 `ccl`에 의해 어셈블리어로 변환
        - 전단부(Front-end): 언어 종속적인 부분 처리(어휘, 구문, 의미 분석)
        - 중단부(Middle-end): SSA 기반으로 최적화 수행(프로그램 수행 속도 향상으로 성능 향상)
        - 후단부(Back-end): RTS로 아키텍처 최적화 수행(더 효율적인 명령어로 대체해서 성능 향상)
2. Link time: 여러 조각 파일들을 하나로 묶어 실행 파일 생성 ==> 런타임 바이너리 생성
- Compile time, Link time 을 묶어 Build time으로 부르기도 함

3. Run time: 실행 파일 실행시 
    - error 발생시 디버깅이 어려움; 환경(OS 등)에 영향이 큼
        - 실행 -> Memory 이슈... (Stack 내용 dump 떠서 분석한다거나)
        - 대부분 프로그램이 멀티 스레딩 환경이므로 동시성 이슈도 고려

#### 컴파일러 구성 요소
- Front-end
    - 어휘 분석기(Lexical analyzer): Token
        - 문자열 형태로 존재하는 소스 코드를 의미 있는 문자 혹은 문자열 조각(토큰)으로 변환
        - 예약어, 상수, 변수, 연산자 등
        - 이 때 자르는 기준(delimiter)은 빈칸(space, \n, \t 등), 세미콜론 등 어느 것이든 될 수 있음
            - 자른다/tokenize 의 의미는 단순히 delimiter 기준으로 `strtok` 하는 것일 수도 있지만, delimiter 기준으로 문자열의 끝에 null(\0) 을 추가해서 나누는 것일 수도 있음
        - 정규 표현식
        ```C
        // human code
        int main()
        {
            int a;
            a = 3+4;
            printf("a is %d\n", a);

            return 0;
        }

        // computer code
        int main(){int a;a = 3+4;printf("a is %d\n", a);return 0;}
        // parse computer code with delimiter, and then analyze syntax
        ```
    - 구문 분석기(Syntax analyzer): Syntax tree
        - 각 토큰을 구문 트리(Syntax tree)로 변환하며 이 과정에서 문법 오류 검출
        - 추상 구문 트리(AST)
            - 트리의 각 노드는 소스 코드에서 발생되는 구조를 나타냄
            * 참고 사이트: astexplorer.net
        - Lexical~Syntax analysis 과정에서 [Symbol table](#심볼-테이블) 생성
    - 의미 분석기(Semantic analyzer): Intermediate Representation
- Back-end
    - 코드 생성기(Code generator): Assemble code + Optimization
        - IR로부터 어셈블리어 등 기계어에 대응될 수 있는 쉬운 명령어 연속(집합)으로 변환
            - function prologue: push stack, ...
            - function epilogue: pop stack, ...
        - 기계어 변환 전 불필요한 코드 제거 등의 최적화 작업
            - 릴리즈 빌드시 function prologue/epilogue 부분을 포함하여 컴파일러 최적화 => 내가 생각하는 **많은 연산이 생략됨**
            1. 불필요한 연산 제거
                - 변수에 대한 의존 관계 분석
                    ```C
                    int a;
                    a = 3+4;
                    some_func(a);
                    // some_func(7); 로 축약 가능
                    /*
                        위 코드에서 a를 역추적 했을 때, a가 쓰이는 곳을 파악해서 그 코드가 정말 필요한지 분석하여 필요 없는 코드는 과감히 제거하고 축약해버림
                     */ 
                    ```
                - 불필요한 상수 연산을 결과로 대체
                - 반복문 내부 불필요한 코드 제거
                    - 예전에는 반복문 내 변수 선언을 지양하였으나, 요즘에는 컴파일러 성능이 좋아져서 상관 없다고 보는 편
                    - 컴파일러가 어마어마하게 코드 축약을 한다
            2. 함수 호출이 필요 없도록 inline화 (함수 호출에 대한 overload 제거)
                - 언어 문법으로 존재하지만 보통은 컴파일러가 자동으로 처리
        - 그럼 뭐가 좋은 코드인가?
            - 컴파일러가 대부분 자동으로 처리해준다면, 컴파일러가 더 쉽게 처리할 수 있도록 지원해주는 코드
                - 나는 오히려 컴파일러가 다 해주니 내가 최적화를 할 필요가 없다고 생각했는데
            - 즉, 상수화를 잘 해라
                - 그런 부분에서는 Pointer 가 오히려 모순적일 수 있음
                - 포인터 변수 자체는 상수화를 하더라도 포인터가 가리키는 주소가 중요한데 그 주소는 어디서 참조될지 모르기 때문에 상수화가 어려움<br>
                -> 이 것들을 전부 다 일일이 고려해서 코드를 짤 수는 없지만, 최소한 컴파일러가 어떤 역할을 하고 내가 어떻게 코드를 짜야 좋은 지를 항상 고민해 볼 것.
    - 어셈블러(Assembler): Machine code
        - 기계어: 말 그대로 기계가 이해할 수 있는 언어, 101010110 이진수
            - 명령 코드(Opcode, Operation code): 기계가 수행할 명령어를 나타내는 부호
                - 명령어를 나타내는 Opcode 외에 피연산자를 나타내는 지정자를 가질 수도,
                - 묵시적으로 피연산자를 가지고 있을 수도,
                - 혹은 피연산자를 아예 갖지 않을 수도 있음
            - 기계어로 번역된 명령은 IP(Instruction Pointer)에 저장되어 Program counter 역할 수행
        - 어셈블리어: 인간이 이해할 수 있는 언어(문자열로 표기)
            - 인간의 언어이므로, 기계에게 명령을 내리기 위해서는 반드시 기계어로 변환(번역)이 필요하다
                - x86, ARM 등 CPU(기계)에 맞춰 변환 가능
            - sub, push, pop, xor, call, add 등
            - disassemble: `binary -> assembly`
                - 리버싱할 때 아주 가끔 디스어셈블한 어셈블리어를 분석하는 경우가 있음
                - 요즘엔 AI가 어셈블리어를 넘어 하이레벨 언어로 역컴파일까지 다 해주는 경우도 생김
        - 실행 파일: CPU가 인식하고 정해진 연산을 수행할 수 있는 명령들의 연속된 유한 집합체
            - 어셈블러가 일해서 나오는 결과물
            - 즉, 인간이 실행하는 바이너리 파일
            - 기계는 연속된 명령어 집합에서 명령을 하나씩 가져와 연산을 실시
            > (연속된 연산 == 실행)

#### 컴파일러 내부 연산
1. 스택 기반 연산 구조
    - 연산을 트리로 표기
    - 피연산자를 자식 노드에 배치
        - 연산자의 우선 순위가 높은 것이 트리 구조상 아래 노드에 위치
    - 스택(트리)를 어느 순서로 읽을 것인가?q
        - V(Visited), L(Left), R(Right)
        - 전위 순회(preorder): VLR
        - 중위 순회(inorder): LVR
        - **후위 순회(postorder): LRV**
    - 역폴란드 표기법(Reverse Polish Notation): 후위 표기법; 연산자를 연산 대상의 뒤에 쓰는 표기법
        - 수식을 계산할 때 특별한 변환 필요 없이, 수식을 앞에서부터 읽어 나가면서 스택에 저장하면 된다는 장점
        - 연산자의 우선 순위가 명확함

    ```
    // ex1. 3+4
    // 연산 순서: 3 4 +
    Stack: push 3
    Stack: push 4
    + : 연산자이므로 스택에서 피연산자 2개 pop

    // ex2. int a = 3+4;
    // 연산 순서 a 3 4 + =
    Stack: push a
    // find a in symbol table
    Stack: push 3
    Stack: push 4
    + : 연산자이므로 스택에서 피연산자 2개 pop
    // solution 1
    // 계산 결과를 별도의 레지스터에 저장
    // solution 2
    // 계산 결과를 동일하게 Stack 에 push
    = : 연산자이므로 스택에서 피연산자 pop
    변수 a에 계산값 할당

    // 만약 할당할 타이밍인데 Stack 에서 pop 한 데이터가 변수(메모리)가 아니고 상수면 write 할 수 없으므로 compile error 발생
    ```
    <img width="385" alt="stack_based_calculate_structure" src="https://github.com/devejs/TIL/assets/48985445/a83b7561-f318-47bd-b26a-10a988b163ea">

    ```
    // 단항 증감 연산자에 대한 다른 접근

    // ex. b = 3+a++;
    // 연산 순서: b 3 a + =
    Stack: push b(변수)
    Stack: push 3(상수)
    Stack: push a(변수)
    +: 스택에서 피연산자 2개 pop
    /*
    이 때, a+3 이라는 연산에서 3은 상수 / a는 변수
    -> 이 연산에서 a라는 변수가 참여하는지 a가 가진 값이 참여하는지가 중요
    -> a+3은 a 의 값에 대한 연산
    반면, a++ 증감 단항 연산자는 변수에 대한 연산
    */
    // a에 포함된 값 + 3 연산 수행됨
    // 이 때, 후위 연산이므로 Stack에서 pop 되고 나서 연산됨
    // 전위 연산일 경우 Stack에 push될 때 연산됨

    ```
    - (단항)증감 연산자: 피연산자를 1씩 증가 혹은 1씩 감소시킬 때 사용하는 연산자 => **변수에 대한 연산**
        - 전위 증감: 다른 연산보다 먼저 수행됨
            - Stack에 **push** 될 때 **변수에 대해** 연산됨
        - 후위 증감: 다른 연산 수행 후에 수행됨
            - Stack에서 **pop** 될 떄 **변수에 대해** 연산됨


#### 심볼 테이블
컴파일러 또는 인터프리터 같은 언어 변환기에서 사용되는 데이터 구조<br>
소스 코드에서 참조되는 심볼들의 이름과 주소가 정의됨
- 심볼
    - 소스 코드의 각 식별자(전역 변수, 함수 등)의 이름(주소)
    - 지역 변수는 특정 블록(메모리) 내에만 존재하며 다른 소스 파일에서 접근할 수 없으므로 (자기 자신의 주소를 가질 수 없으므로) 심볼이 될 수 없다
- 컴파일러 내부에서 사용되는 용도
    1. 어휘 분석(Lexical Analysis): 심볼 테이블에 새 엔트리 추가(토큰)
    2. 구문 분석(Syntax Analysis): 테이블에 attribute 에 대한 정보 추가 (타입, 범위, 레퍼런스, 참조 등)
    3. 의미 분석(Semantic Analysis): 테이블에서 가능한 정보를 가져와서 의미 확인 (type checking: 표현식, 할당문이 의미상 올바른지 체크해서 업데이트)
    4. 코드 생성(Intermediate Code generation): 런타임에 어떤 타입이 얼마나 할당되었는지 파악 및 임시 변수 정보들을 추가하는데 심볼 테이블 참조
    5. 코드 최적화(Code Optimization): 최적화(machine-dependent) 하는데 심볼 테이블의 정보 사용
    6. 타겟 코드 생성(Target Code generation): 테이블의 식별자 주소정보 사용해서 코드 생성


### 함수
#### 호출 관계와 void 반환
- main 함수: 내가 호출하지 않고 시스템이 호출하는 함수(일종의 진입점)

<img width="570" alt="function_call_process" src="https://github.com/devejs/TIL/assets/48985445/6a3c9592-ada8-4209-9150-e62362909ed0">

- Caller(호출자 함수)
    - Callee 함수 호출; 호출 후 그 내부에서 어떤 연산/호출이 있는지는 신경 쓰지 않음
- Callee(피호출자 함수)
    - callee라도 caller가 될 수 있다
    - **return**의 의미
        1. return 값 자체로의 의미(add 함수에서 연산한 값 반환 등)
        2. callee 함수의 결과 확인(성공/실패)
        3. void 반환: 결과에 관심x 호출에만 의의
- 특이한 함수 생성자(Constructor)
    - C++ 에서 도입된 개념으로, 생성자에서는 아예 반환 자체를 하지 않는다<br>
        -> 의도된 호출이 없다

* 멀티 스레드/모듈을 고려하지 않으면 호출 흐름이 눈에 보이기 때문에(예측 가능) 반환값이 큰 문제가 되지 않는다
* 그러나 모듈별로 분리가 되거나, thread를 사용하게 될 경우 문맥 교환 중 예측 불가능할 가능성이 커짐
    - 특히, Thread가 도입되게 되면 연산은 CPU(HW) 에서 하지만, 스케줄링은 OS가 하기 때문에 실행 순서를 보장x

#### 매개 변수 전달 기법
매개 변수도 일종의 자동 변수
- 자동 변수 + Stack(Stack 구조로 관리되는 메모리; [참고](#메모리-구조))
    - 컴파일러가 이 변수 메로리를 관리하는 코드를 생성함 -> 메모리가 자동으로 관리됨(자동 변수)

전달 기법
- Call by value: 스택에 값 복사
- Call by address: 복사하는 값이 메모리의 주소
    - 엄밀히 말해서 call by value 에 속하기도 하고 pointer로 구현한 Call by reference 기도 함
- Call by reference: C언어는 참조형이 없어 포인터로 구현
    - Call by address나 reference나 하이 레벨 언어에서 사용하는 개념이고, 기계어 수준에서는 동일한 기작

함수 호출시
- Stack 사용
- Register 사용: 속도는 빠르나 메모리 크기가 크지 않음
- Stack과 Register 병용

#### 싱글 스레드 프로세스
프로그램을 만들면 하나의 Process 생성
- 하나의 Process에는 기본적으로 하나의 Thread 포함
- 기본적으로 Single Process - Single Thread 모델로 Thread 수준 동작
- Thread attached Stack
    - 하나의 스레드마다 Stack이 존재하는데, 컴파일러에서 별도로 설정해주지 않으면 기본적으로 **1MB** 로 설정된다. (Visual Studio 기준, gcc 확인 필요)
    - Visual studio 설정에서 스택 크기 수정 가능하나, 이를 넘어서서 사용하는 건 좋지 않음
    - 스레드 내에서 스택 사이즈가 초과되면 -> **Stack Overflow**
        - 이 이후로는 연산 자체가 불가능함
            1. 과하게 stack 을 사용하지는 않았는지
            2. 함수 호출 관계가 너무 복잡하게 이어지지는 않았는지 확인<br>
                -> 무분별한 함수 호출은 좋지 않음

#### Stack Frame 지정 원리
Stack이란 Stack 구조로 관리되는 메모리로,<br>
Stack Frame이 지정된다는 의미는 곧 가상의 Stack에 할당되는 데이터들이 실제 메모리에 어떤 원리(규칙)으로 저장된다는 의미
- x86(32bit) 기준의 Stack Frame 지정 원리
    1. 스택 메모리 주소는 0번지를 향해 증가
        - 특정 메모리 주소부터 시작되어, 점점 주소가 작아지는 방향으로 데이터가 쌓인다(저장된다).
    2. 지역 변수는 선언한 순서대로 push
    3. 배열은 0번 요소가 상단에 배치
        - 배열은 인덱스가 증가하면 주소가 증가하기 때문에, 이전에 선언된 변수보다는 주소가 작되(2번 원리) 0번 인덱스가 가장 주소가 작다
    4. 매개 변수는 오른쪽부터 스택에 push (함수)
        - C++에서 default parameter 와 연결됨
        - 함수 호출시, 매개 변수가 함수 내 지역변수보다 먼저 push 됨
    5. 스코프 단위로 끊어서 표시 (함수는 별도 단락으로 표시)
        - 2번 원리에 의해 변수가 push 되다가도, 함수 내부에 또 다른 스코프(if 문 등)가 생기면 분리해서 간다는 느낌
        - 함수에서 별도 단락으로 표시해야 하는 이유: 6번 참고(함수 종료 후 이전 실행 포인트에 돌아가기 위해 필요함)
    6. 함수 반환시 해당 함수가 사용한 스택 메모리는 그림에서 삭제
        - Call stack: 현재 실행 중인 서브루틴(함수)에 관한 정보를 저장하는 스택 자료구조
            - 현재 실행 중인 서브루틴의 실행이 끝났을 때, 제어를 반환할 지점을 보관 -> **Stack Pointer**
            - 서브루틴(함수)이 종료되면, 해당 함수에 대한 스택 메모리가 삭제(할당-해제)되는 것은 아니고 스택 포인터의 위치(가리키는 값)이 바뀜
    7. 전역, 정적(지역) 변수는 스택 사용x [참고](#메모리-구조)
    8. 포인터는 가급적 별도로 표시
        - 포인터도 변수이므로 Stack 에 저장되지만, 실제 가리키는 주소는 다른 곳이기 때문에 스택 구조에서 별도로 표기
    9. 함수 호출시 Callee 함수가 사용할 스택 메모리의 크기는 **Compile time**에 결정됨
- 64bit 기준으로는 지정 원리가 다르기 때문에, 위 규칙이 항상 적용되는 것은 아니다
- 식별자 검색 순서: 스택 위 -> 아래 방향으로 검색
    - 즉, 주소가 커지는 방향으로 순차적으로 검색함
    - 지역 변수는 기계적으로 단순 해석되기 때문에 symbol이 사용되지 않음
    - 그러나 지역 변수 범위를 넘어서면 symbol table 사용(식별자 검색에 참조됨)
- 스택 오버플로우가 나는 흔한 원인
    1. DB 등을 구현하려고 했을 때, 비선형 자료구조의 깊이를 너무 깊게 했을 때
    2. 깊이가 깊은 자료 구조 탐색 등으로 재귀 호출을 해야만 하는 경우
    3. 프레임워크 등 사용시, 구조를 잘 모르면 상호 호출을 하게 되는 실수 (a에서 b 호출, b에서 a 호출)
    - 스택 오버플로우 발생시, 설계를 다시 고려해 봐야 한다(알고리즘 풀 때 특히!)
    - 그리고 가능하면 동적 할당 하세요

#### 함수 호출 규약(Call Convention)
함수 호출로 증가한 스택 메모리 사용 및 관리에 관련된 규약<br>
- x86 호출 규약
    - `__cdecl`: C Declaration; 호출자(Caller)가 스택 정리
        * 호출 함수는 함수 호출이 반환된 뒤 스택을 정리
    - `__stdcall`: Standard Call; 피호출자(Callee)가 스택 정리
    - `__fastcall`: Fast Call; 매개변수에 레지스터 사용
        * 표준 규약은 아님. 컴파일러마다 다르게 처리될 수 있음
- Visual studio 기준으로 `__cdecl`가 default 값이나, 개발자가 직접 지정하거나 컴파일러 설정 변경 가능
- 동일 언어를 쓰는 환경이어도 필요에 의해 여러 개의 호출 규약을 사용할 수 있음

후일 참고할 일이 생긴다면 [요기 참고](https://ko.wikipedia.org/wiki/X86_호출_규약)

### 파일 입출력
#### 파일 시스템
저장 장치를 관리할 수 있는 체계
- 하드 디스크
    <img width="691" alt="HDD_구조" src="https://github.com/devejs/TIL/assets/48985445/dcf91526-4621-48be-9ce0-880ddccd42e2">
    - 자기장의 밀도 변화를 이용해 디지털 신호를 플래터에 기록하는 저장 장치
        1. 스핀들 모터로 플래터 회전
        2. 제어 회로가 액추에이터에 명령을 내려 액추에이터 암이 구동되며(네오디뮴 자석), 액추에이터 암에는 헤드가 달려 있다.
        3. 플래터에는 여러 개의 액추에이터 암이 있고, 스핀들 모터가 작동할 때 헤드가 부상하여 데이터를 읽고 쓴다. 
            - 자기장의 밀도 변화를 측정하는 바늘(헤드)가 플래터 위의 일정한 간격을 지나치는 동안 자기장의 극성이 변화하면 1, 그렇지 않으면 0으로 인식
    - 플래터는 Track 과 Sector 로 분류되고, 각각의 고유 번호가 존재
    - HW마다 다를 수 있지만, 보통 Sector 하나에 512byte
        - 2개에 1KB, 4개(2KB)를 묶어 Cluster
    - Page(4KB) 단위로 데이터를 관리하는데, 어떤 식으로 데이터를 관리할 것인지 => 파일 시스템
- File system
    - 파일 시스템 적용
        1. File System 선택
        2. 적용(파티션(Volume) 분할 등)
        3. format: 1,2번의 내용을 Table에 정리
            - FAT(File Allocation Table): Track/Sector를 모아 관리하는 파일시스템 내부 테이블
    - 파일 시스템 구조
        - 가상 메모리는 메모리에 연속성이 있지만, Track/Sector는 연속성이 없다
        - 그래서 일종의 Linked List 같은 구조를 가짐(Sector(p)-Sector(p)-...)
        - 장점: 한 Sector의 크기를 초과하더라도 연속될 필요 없이 저장 후 Link 됨 => **File 은 연속성이 없음**

- File
    - File과 Memory의 차이
        - Memory (RAM, 엄밀히는 VMS): 1차 메모리; R/W시에 크기 할당되어 정해진 크기로만 제한됨
        - File: 2차 메모리; 특이하게 생성시 0byte 로 시작하여 write 하면 그만큼의 메모리가 추가 할당됨 => **크기 제한 없음**
    - File 은 연속성이 없다
        - 즉, 크기에 둔감함
        - 디스크에 물리적으로 여유 공간만 있다면 File system이 관리할 수 있는 한도로는 무한정 확장 가능
- 파일이 저장되는 방법
    1. file write request
    2. HDD 특정 Sector, Track 에 write
    3. 2번의 내용이 FAT에 기록됨
        - Track, Sector, Filename 등의 데이터
        - Delete 관련 데이터가 있음
            - 파일 삭제시 메모리가 지워지는 것이 아니라, FAT에서 삭제 여부로 표기
            - 관리 체계에서 제외됨; 후에 다른 데이터로 overwrite
            - overwrite 되기 전에는 복구 가능한 이유

- 텍스트와 바이너리의 차이
    - 텍스트 < 바이너리
        - ASCII 가 정수로 해석될 수 있는 것과 같은 원리
        - 즉, 데이터 값이 바이너리 중 텍스트로 분류 가능한 조건 1
        - -1 에 대한 해석(EOF)이 다름
        - Copy con test.txt 명령
                <img width="435" alt="file_device_con" src="https://github.com/devejs/TIL/assets/48985445/f2a9586f-9414-4e23-b226-b4c53a8eb54b">
            - con(CON): console Device File
                - File 은 어떤 Device에 대한 interface
                - Device File은 일반 data file과 구별 필요
            - Console 에 들어온 input 을 test.txt 파일에 copy 하는 커맨드
                - 인풋의 끝은 윈도우 기준 ^Z(Ctrl+Z)
            - Console 에 I/O Write 를 한 것이 Device로 전달되는 형태(즉, printf, fput 과 같은 동작)



#### Reference
- [독하게 되새기는 C 프로그래밍](https://www.inflearn.com/course/독하게-되새기는-c프로그래밍/dashboard)
- [IEEE754](https://ko.wikipedia.org/wiki/IEEE_754)
- [추상 구문 트리](https://ko.wikipedia.org/wiki/추상_구문_트리)
- [JAVA 기반 연산 구조(Stack, Register) 참고 블로그](https://www.korecmblog.com/blog/jvm-stack-and-register)
- [역폴란드 표기법](https://ko.wikipedia.org/wiki/역폴란드_표기법)
- [심볼 테이블](https://ko.wikipedia.org/wiki/심볼_테이블)
- [Symbol table in compiler](https://www.geeksforgeeks.org/symbol-table-compiler/)

======================================================
###### 231024 TIL
###### 231027 TIL
###### 231028 TIL
###### 231029 TIL
###### 231103 TIL
###### 231104 TIL
###### 231105 TIL
###### 231116 TIL
###### 231117 TIL
###### 231118 TIL
###### 231119 TIL
###### 231123 TIL
###### 231124 TIL
###### 231125 TIL
###### 231126 TIL
###### 231127 TIL
###### 231130 TIL
###### 231201 TIL