# Data Structure

## Why?
### 자료구조란?   
> 데이터를 효율적으로 접근, 수정, 저장, 관리하기 위해 구조화한 것

자료의 특성에 따라 분류, 저장, 처리하기 때문에 어떤 자료 구조를 쓰냐에 따라 데이터 처리의 성능이나 효율이 달라진다.

1. **선형** 자료 구조: 배열, 연결 리스트, 스택, 큐 등
2. **비선형** 자료 구조: 트리, 그래프 등

## 기초 자료구조
### 배열
**동일한 데이터형 변수**를 메모리상 **연속적인 공간**에 할당함<br>
다른 데이터형 변수를 가질 수 있는 구조체와는 다름
- 특징
    - 배열명이 곧 배열의 시작 주소 **상수**
    - 초기화
        1. 전체 초기화는 선언할 때만 가능: `{...};`
        2. 문자열 초기화/배열은 [여기 참고](../c_cpp/string.md)

### 연결 리스트
데이터를 저장한 단위 메모리가 서로 연결됨 <br>
* 단위 메모리: `Node`; {데이터 저장 + 포인터}
* 다뤄야 할 주요 기능
    1. 연결 리스트 생성
    2. Node 추가
    3. 전체 Node 출력
    4. Node 검색/삭제/정렬
    5. 연결 리스트 소멸

#### 단일 연결 리스트
각 노드에 다른 노드를 가리키는 포인터가 하나씩만 있는 연결 리스트

> - Head Node: 연결 리스트의 첫 번째 노드
> - Head Pointer: Head Node를 가리키는 포인터 (필수)
> - Tail Node: 연결 리스트의 마지막 노드
> - Tail Pointer: Tail Node를 가리키는 포인터
> - Node count: Node의 개수; 혹은 실제 데이터를 가진 Node의 개수

* 단일 연결 리스트 관리  
    * Head Node, Tail Node에는 데이터를 넣지 않고 관리하는 방법<br>
    -> 실제 코드 작성시 편의성 증가<br>
    * *Why?*<br>
        * 모든 노드에 데이터를 넣을 경우
        ```c++
        // 특정 노드 삭제가 필요할 때
        if (HEAD_NODE 삭제) {...}
        else if (TAIL_NODE 삭제) {...}
        else {...}  // 중간 노드 삭제
        ```
        * 중간 노드에만 데이터를 넣을 경우
        ```c++
        // 모든 경우에 중간 노드만 삭제하게 되므로
        // 중간 Node만 처리하는 단일 코드 작성
        ```
        > HEAD, TAIL의 메모리는 증가하지만 코드가 깔끔해지고 처리 속도가 빨라짐



### 배열과 연결 리스트의 차이
|연결 리스트| Difference |배열|
|------|---|---|
|Node(구조체) 연결 방식|구현 방식|고정 크기 메모리|
|높음<br>필요한 만큼만 사용 가능|메모리 효용성|낮음<br>고정된 사이즈로 불필요한 메모리 사용|
|빠름<br>중간에 끊어서 다시 연결해주기 용이함|삽입&삭제 속도|느림<br>원소 이동 필요|
|느림<br>순차적으로 접근해야 함|원소 접근 속도|빠름<br>인덱스로 직접 접근|
|복잡|구현 복잡도|간단|


### 스택
데이터가 FILO(First In, Last Out) 으로 쌓이는 자료 구조<br>
입구와 출구가 동일
* 배열이나 연결 리스트로 구현
* 다뤄야 할 주요 기능
    1. 스택 생성
    2. 스택 Full/Empty 검사
    3. 스택 상단에 데이터 추가(push), 꺼내기(pop)
    4. 스택 내의 모든 데이터 출력 
    5. 스택 소멸

> - size: 스택의 공간 크기(저장 가능한 데이터의 양) 
> - push: 스택에 데이터를 넣음
> - pop: 스택에서 데이터를 꺼냄
> - top: 스택에서 데이터를 입출력할 데이터의 위치(index)

### 스택 구현
```C++
// 스택 관리 구조체
typedef struct_stack
{
    int *stack;     // 스태긍로 사용되는 동적할당 배열 주소
    int size;       // 스택의 크기
    int top;        // 스택의 입출력 위치 정보
} Stack;

// 구현해야 할 함수들
bool createStack();
bool isStackFull();
bool isStackEmpty();
bool push();
bool pop();
void printStack();
void destroyStack();
```
* [C로 구현]() <br>
* [C++로 구현]()


### 큐
데이터가 FIFO(First In, First Out) 으로 쌓이는 자료 구조<br>
입구와 출구가 구분됨
* 배열이나 연결 리스트로 구현
* 다뤄야 할 주요 기능
    1. 큐 생성
    2. 큐 Full/Empty 검사
    3. 큐에 데이터 추가(put), 꺼내기(get)
    4. 큐의 모든 데이터 출력 
    5. 큐 소멸

> - size: 큐의 공간 크기(저장 가능한 데이터의 양) 
> - put(enqueue): 큐에 데이터를 넣음
> - get(dequeue): 큐에서 데이터를 꺼냄
> - front: 큐에서 출력할 데이터의 위치(index); 첫번째 데이터 위치
> - rear: 큐에서 입력할 데이터의 위치(index); 마지막 데이터+1

#### 일반 큐를 쓰지 않는 이유
일자 큐는 1회성으로밖에 사용할 수 없다.<br>
```c++
// 큐가 비어있는 경우; front == rear
const int SIZE = 3;
int que = new int[SIZE];
int front = 0, rear = 0;

que[rear++] = 10;   // rear == 1;
que[rear++] = 20;   // rear == 2;
que[rear++] = 30;   // rear == 3;
// 큐가 꽉 차있음; SIZE == rear;

// 데이터를 빼냄
// dequeue 구현 안 되었으므로 front++ 로 get 처리
int data = queue[front++];  // front == 1;
data = queue[front++];      // front == 2;
data = queue[front++];      // front == 3;

/*
데이터를 전부 빼냈으므로 큐는 비어 있음
그런데???
SIZE == rear == front == 3
empty인지 full인지 알 수가 없는 상태가 됨
-> 재사용 불가
*/ 
```

### 원형 큐
일반 큐의 단점(1회성) 해결한 자료 구조<br>
FIFO를 유지하되, 큐의 입구와 출구 연결(당연하지만 물리적으로 연결한다는 뜻은 아님)
* 완충지대 개념 
    - 원형 큐의 Empty/Full 상태를 구분하기 위해 front/rear 사이 비어 있는 인덱스 개념 도입
    - 데이터 저장하지 않는 인덱스
    - `if (rear == 완충지대) { // Full };`
    - `if (front == rear) { // Empty };`
    - 이전 일자 큐가 문제였던 부분, 꽉 찬 상태일 때 front와 rear가 같은 곳을 가리키면 안 됨 => 완충지대가 필요한 이유
    - 완충지대 위치: **front 앞 index**
        - 원형 큐는 데이터를 빼고 넣으면서 계속 인덱스가 움직이기 때문에 완충지대 역시 움직이게 된다(무조건 마지막 x) 
* `rear = (rear+1) % Q_SIZE`

### 큐 구현
```C++
// 큐 관리 구조체
typedef struct_queue
{
    int *queue;         // 큐로 사용되는 동적할당 배열 주소
    int size;           // 큐의 크기
    int front, rear;    // 큐의 출/입력 위치 정보
} Que;

// 구현해야 할 함수들
bool createQueue();
bool isQueueFull();
bool isQueueEmpty();
bool enqueue();
bool dequeue();
void printQueue();
void destroyQueue();
```
* [C로 구현]() <br>
* [C++로 구현]()


### 해시 테이블
키(Key)와 값(Value)으로 이루어진 데이터를 저장하기 위한 자료구조<br>
검색하고자 하는 key를 해시 함수를 통해 해시값으로 변경, 해당 값을 index로 하여 value 저장/검색/관리
* 자료수 N과 관계 없이 빠른 성능을 가짐
* 배열이나 연결 리스트로 구현
* 다뤄야 할 주요 기능
    

> - slot: 1개의 레코드를 저장할 수 있는 공간; n개의 슬롯이 모여 버킷을 형성함 
> - bucket: 레코드를 저장하는 공간; 한 버킷은 하나 이상의 레코드를 수용함 
> - Hash Table: 버킷의 집합
> - key: 해시 테이블에서 레코드를 찾기 위한 값
> - Hash Value: 레코드를 해시 테이블에 저장하기 위한 위치 값
> - Hash Function: 키를 해시 값으로 바꿔주는 함수
> - *Hash Collision*: 서로 다른 2개 이상의 레코드가 같은 해시 값을 갖는 현상<br>
>   -> **해당 현상을 해결하는 것이 핵심**<br>
>   1) Synonym이 없게 해시 테이블 생성
>   2) Synonym이 있더라도 부가적인 방식으로 해결할 수 있게 해시 테이블 생성
> - Synonym: 같은 해시 값을 갖는 레코드들의 집합
> - Overflow: 계산된 해시 값의 bucket 내에 저장할 기억 공간이 없는 상태;
>   - 버킷을 구성하는 슬롯이 여러 개일 때는 Collision은 발생하나 Overflow는 발생하지 않을 수 있다. 
>   - 해시 테이블 > 버킷 > 슬롯
>   - 해시 값으로 찾아간 데이터는 결국 버킷 안의 슬롯에 들어있는 레코드; 버킷은 여러 개의 슬롯으로 이루어질 수 있으므로 해시 값이 충돌하더라도 저장할 여유 공간은 존재할 수 있다

* 해시 함수 작성시 고려사항
    * 평균적인 입력에 대해 해시값의 분포가 고르게 잡히는 것이 좋은 해시 함수
    * 특정 해시 값이 많이 나오게 되면 버킷이 넘치게 되므로 부가적인 작업 필요함
    * 해시 함수가 사용할 수 있는 연산 형태: `나머지, 제곱, 나누기, 합치기` 등
    * 해시 값은 테이블의 크기를 초과해서는 안 됨

### 해시 검색법
상수의 검색 시간을 가지는 매우 빠른 검색 기법

#### 해시 선형 탐색법
* 정적인 해시 테이블을 이용해 구현
    * 배열과 같이 이미 크기가 정해진 해시 테이블
* 자료 변동이 별로 없는 경우에 적합함
* 구현 난이도 쉬움
* 문제점: 속도 저하 이슈가 발생할 수 있음<br>
    -> 해시 테이블을 쓰는 이유가 빠른 속도(성능)인데, 속도가 선형 검색(N)에 가까워지면 사용 의미가 없음

#### 구현
```C++

// 구현해야 할 함수들

```
* [C로 구현]() <br>
* [C++로 구현]()


#### 해시 연결법(Seperate chaining)
동적 할당을 통해 해시 테이블의 크기보다 큰 자료를 저장<br>
기본적인 해시 테이블 + 연결 리스트 => 동적인 자료 검색
* 대용량 자료 처리에 유리함
    * 처리 가능한 자료 수가 메모리 limit이나 디스크 용량에 의해 결정됨
* 자료 변동이 별로 없는 경우에 적합함
* 구현 난이도 쉬움



### Reference
- [인프런 판타스틱 자료구조 입문](https://www.inflearn.com/course/판타스틱-자료구조-입문)



======================================================
###### 230612 TIL
###### 230615 TIL
###### 230616 TIL
###### 230617 TIL