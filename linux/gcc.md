# GCC

## 컴파일
인간이 이해할 수 있는 형식 언어(C,C++ 등) 로 작성된 소스 코드를 CPU가 이해할 수 있는 기계어로 번역하는 과정
- 인스트럭션: CPU 가 이해할 수 있는 이진수로 이루어진 명령
    - 하나의 인스트럭션은 어셈블리 코드와 1대 1 대응
    - `objdump`: 바이너리 파일의 정보를 보여주는 명령어
        - `-S` 옵션: 디버깅 정보 + 인스트럭션 + 어셈블리 코드

### 컴파일 과정
*gcc 컴파일러를 사용
- `/usr/bin/gcc`: 컴파일러 드라이버
    - 실제 컴파일 과정을 처리하는 것이 아니라, 전처리기-C컴파일러-어셈블러-링커, 즉 컴파일 과정에 필요한 명령을 순차적으로 호출해주는 역할
    - 내부 동작
        1. 전처리: `cpp0` 또는 `cc1 -E` 명령을 호출
        2. 컴파일: `cc1`
        3. 어셈블: `as` -> 목적 코드
        4. 링크: `collect2` -> 내부적으로 링커인 `ld`를 호출해 라이브러리와 링크 -> 실행 파일 생성
    - 소스 파일의 확장자를 해석해 지원하지 않는 언어이더라도 해당 소스에 맞는 전처리기와 컴파일러를 호출해주기도 함
        - 기본 라이브러리 수동 추가 필요

#### 전처리
`cc1 -E` 실행시 동작
0. 입력으로 지정한 소스 파일 읽기
1. 헤더 파일 삽입
    - `/usr/local/include` > `/usr/lib/gcc-lib/.../include` > `/usr/include` 디렉터리 순서로 헤더 파일 탐색 (시스템 헤더 파일)
    - 유닉스 계열 시스템은 `/usr/include` 디렉터리에 헤더 파일들 보관
    - `gcc -I[include dir]` 옵션 사용시 해당 디렉터리 먼저 탐색
    - 헤더 파일을 붙여넣는 중간에 다른 `#include <파일>` 이 나오면 붙여넣기를 중단하고 해당 파일을 찾아서 그 위치에 붙여넣음 > 완료시 재개 
2. 매크로 치환 및 적용
    - `#define`된 부분은 `cc1 -E`의 심볼 테이블에 저장
    - 심볼 테이블에 들어있는 문자열과 같은 문자열을 만나면 define 된 내용으로 치환
    - `#ifdef` 와 같이 선택적 매크로도 이 때 처리됨
    - predefine 매크로
        - 소스상에 define 되지 않았지만 전처리기가 임의로 define해주는 매크로
        - `__FILE__`, `__LINE__` 등과 같이 이미 소스 파일 내에 정의된 것
        - 주로 디버깅 출력 메시지에 사용
        - 시스템/컴파일러 종류마다 코드를 구분해 컴파일 할 때도 사용

#### 컴파일
`cc1` 실행시 동작
1. 전단부(front-end): 언어 종속적인 부분 처리
    - 소스 코드가 올바르게 작성되었는지 분석
        1. 어휘 분석: 전처리된 C 코드(.i)를 의미가 있는 가장 최소 단위로 나누기
            - 토큰: 문법적으로 의미 있는 가장 최소 단위의 문자열
                - 지정어(if,while, ..), 연산 기호, 구분자, 명칭(main, printf, ..), 상수
            - 나누어진 토큰은 구문 분석을 담당하는 파서에 넘겨짐
        2. 구문 분석: 프로그램의 문법상 오류 찾기
            - 파스 트리를 만들며 문법적 오류 체크
                - 문법적 오류 발생시 파스 트리가 제대로 생성되지 않음
        3. 의미 분석: 문법상 오류는 없지만 의미상 오류 체크
            - 선언되지 않은 변수, 인자 개수, 자료형 불일치 등
            - 1,2 단계에서 구축된 심볼 테이블 이용
    - 중단부에 넘겨주기 위한 GIMPLE 트리(소스코드를 트리 형태로 표현한 자료 구조) 생성
        4. 중간 표현 생성: 언어 종속적/기계 종속적 부분을 분리해 컴파일러를 모듈화, 최적화를 쉽게 하기 위한 중간 표현 생성
            - GIMPLE 트리: 언어 독립적인 특성을 제공하기 위해 사용하는 트리 형태의 중간 표현
                - 여러 프로그래밍 언어 소스를 공통된 언어 표현으로 바꾼 후 소스 코드를 트리 형태로 표현
                    1. 파스 트리를 언어의 AST(Abstract Syntax Tree)로 변경
                        - *AST: 토큰만으로 이루어진 트리
                        - 파스 트리에서 구문 분석을 위해 실제 코드에는 없는 non-terminal 들을 가지고 있는데, 이러한 불필요한 정보 제거
                    2. AST를 언어 종속적이지 않은 GENERIC 트리로 변경
                    3. Gimplify: GENERIC 트리를 간소화시켜 GIMPLE 트리 생성
            - RTL: 기계 독립적인 특성을 제공하기 위해 사용하는 거의 어셈블리 수준의 중간 표현
2. 중단부: 아키텍처 비종속적인 최적화
    - GIMPLE 트리를 이용해 **아키텍처 비종속적인 최적화** 수행
        1. SSA(Static Single Assignment) 형태 변환
            - 변수에 값을 한 번만 할당하는 중간 표현의 한 가지 형태
            - side effect가 없고, 데이터 흐름이 명시적으로 표현되어 최적화 구현에 용이함
        2. 인터프로시저 분석: 함수 inline 수행, 동적 프로파일링 코드 삽입 등
            * gcov, gprof (프로파일링 분석 툴)
        3. SSA 기반 아키텍처 비종속적인 최적화
            - 최적화: 기능은 동일하나 크기가 작고, 빠르고, 메모리를 적게 사용하도록 코드를 변경하는 작업
            1. 지역 최적화: 공통 부분식 제거, 연산 강도 경감, 상수 계산 등
            2. 전역 최적화: 공통 부분식 제거하고 사용되지 않는 코드 제거
            3. 루프 최적화: 루프 내에서 불변하는 코드 루프 밖으로 조정, 합칠 수 있는 루프는 하나로 합치는 등 조정
            - 최적화 리스트
                - 각종 반환 값 최적화
                - 전체 중복성 제거
                - 조건부 상수 전파
                - 데드 코드 제거
                - 복사 전파
                - value range propagation
                - branch prediction and profiling
                - dead store elimination
    - 후단부에서 사용하는 RTL(Register Transfer Language) 생성
        - RTL: 레지스터 전송 언어; 고급 언어와 어셈블리 언어의 중간 형태
            - 레지스터 레벨의 연산과 오퍼랜드로 표현
            - 특정 아키텍처에 종속적이지 않고 많은 아키텍처를 포용할 수 있게 설계됨
            - RTL 파일: RTL 에서 정의하는 아키텍처의 머신 코드
        1. RTL 코드를 이용해 최적화 과정을 수행
        2. 실제 아키텍처에 맞게 연산자와 메모리 액세스 방식 변경
        3. 가상의 레지스터들을 실제 물리 레지스터에 맵핑
        4. 실제 타켓 머신의 어셈블리 파일로 변환
        
3. 후단부: 목적 코드 생성
    - 아키텍처 비종속적인 최적화 + 아키텍처 종속적인 최적화 수행
        - 아키텍처 종속적인 최적화: 아키텍처의 특성을 타는 최적화;
            - 기계 숙어 변환: 여러 인스트럭션을 아키텍처에서 지원하는 하나의 인스트럭션으로 바꾸는 기법
            - 인스트럭션 스케줄링
            - **레지스터 할당**
                - 무한한 가상 레지스터를 사용하게 작성된 코드를 실제 아키텍처에 있는 제한된 개수의 물리 레지스터를 사용하게 바꾸는 일
                    - RTL을 생성할 때 코드 내 사용된 지역 변수, SSA나 여러 최적화 기법을 통해 생성디는 임시 변수들이 가상 레지스터에 할당됨
                    - 가상 레지스터들이 레지스터 할당을 통해 싪제 물리 레지스터 또는 메모리로 변환
            - 메모리 접근의 최적화
            - 연산 순서 조절
            - 각종 loop 최적화
    - 최적화 완료 후 목적 코드 생성
        - 목적 코드: 타겟 아키텍처의 어셈블리 코드; 이후 어셈블러에 의해 인스트럭션(기계어)으로 변환됨

#### 어셈블
`as` 실행시 동작
- object 파일 생성
    - ELF 바이너리 포맷 구조: 바이너리 파일의 구조를 결정짓는 규약
        - 인스트럭션 + 데이터
        - 바이너리 포맷이 필요한 이유
            1. 링커가 여러 파일들을 링킹할 때, 여러 바이너리가 일정한 규칙을 가지고 있지 않다면 링킹하기 쉽지 않다
            2. 어디까지가 인스트럭션이고, 어디까지가 데이터인지 구분
            3. 링킹 후 실행하더라도 커널 로더(execve() 시스템 콜)가 어떤 식으로 실행해야하는지 알 수 없음
            - 즉, 오브젝트 파일/실행 파일은 그 자체로서 링커/로더에게 정보를 제공해야 하기 때문에 규칙(포맷)을 정해 제공함
        - 유닉스: `a.out`, `ELF`, `COFF` 등
        - 윈도우: `COFF`, `PE 포맷` 등

    - object 파일 구조
        - ELF Header: 엔디안, 운영체제, CPU 정보, 바이너리 내부 각 구역의 시작 위치와 크기 정보
            - `readelf` 명령어로 ELF 포맷 바이너리 정보 확인 가능
        - Program Header Table(optional): 커널 로더에 필요한 정보를 제공하는 테이블
        - `.text`: 텍스트 섹션; 인스트럭션이 들어 있는 부분
        - `.data`: 데이터 섹션; 데이터가 들어 있는 부분
        - `.bss`: 초기 값이 0인 전역 변수에 할당되는 공간
        - `.rodata`: 읽기 전용 데이터(read only) 섹션
        - ...: 링커, 로더, 디버거에게 정보를 제공하기 위한 기타 섹션들로 구성
            - 심볼 테이블
                - 심볼: 메모리상의 주소를 가지는 모든 것; 전역 변수, 함수, 전역 구조체, 정적 변수 등<br>
                -> 이름, 크기, 종류, 스코프 등의 정보 포함
            - 재배치 섹션
        - Section Header Table

#### 링크
`collect2` 실행시 동작

- 라이브러리: 프로그래밍에 사용할 수 있게 미리 만들어져 있는 함수나 변수들의 묶음; 이미 컴파일되어 있어 링크만 하면 바로 사용 가능하다
    - 정적 라이브러리
        - 표준 C 라이브러리: 별도로 컴파일 과정에서 링크하지 않아도 자동으로 링크됨 (`/usr/lib/libc.a`)
        - 이런 표준 C 라이브러리 내 함수 등이 오브젝트 파일로 컴파일되어 하나의 파일로 묶여 있는 형태 (즉, 여러 함수의 ELF 오브젝트들이 묶여 있는 형태)
        - 보통 `lib[라이브러리 이름].a` 형식으로 저장됨
        ```Shell
        mkdir libc  # 임시 디렉터리 생성
        cd libc
        cp /usr/lib/libc.a ./
        ar -x libc.a    # ar -x 명령으로 libc.a 파일을 푼다
        ```
        위 명령으로 `libc.a` 파일이 어떤 파일로 묶여있는지 알 수 있음<br>
        -> 수많은 오브젝트 파일들의 묶음
        - 정적 라이브러리 단점: 각각의 실행 파일에 같은 오브젝트 파일이 중복되어 링크되기 때문에 실행 파일의 크기가 커짐 -> HDD 공간 낭비, 실행시 메모리 낭비
    - 정적 라이브러리 사용시 링크 동작
        1. 내부적으로 `ld`를 호출
        2. ld는 입력되는 순서대로 각 오브젝트의 text/data/bss 섹션을 순차적으로 붙이면서 바이너리 구성
        3. 실행 바이너리 맨 앞/뒤에 프로그램 수행 전 초기화/종료시 사용하는 startup 코드 추가됨
 
    - 공유 라이브러리
        - 여러 함수를 포함하는 하나의 큰 ELF 바이너리 형태
        - 링킹 후 함수 호출시 직접 호출하는 것이 아니라 PLT 섹션에 포함된 특정 영역을 호출하게 링크
            - PLT(Procedure Linkage Table)


## gcc 사용

### gcc 옵션
gcc 명령이 내려지면 gcc C 컴파일러 드라이버에 의해 해석되고, 각 옵션이 종류별로 분류되고 해당 괴정(전처리, 컴파일, 어셈블, 링킹)을 수행하는 바이너리를 실행할 때 기본 옵션에 추가되어 수행됨
- 옵션 종류
    - C 컴파일러 드라이버 옵션
        - Overall Options: 컴파일 과정을 어디까지 진행할 것인지 / 컴파일 진행 과정을 출력할 것인지 등을 조절
    - 전처리기 옵션: 매크로 정의 및 비정의 등
    - 컴파일러 옵션
        - C Language Options: C 언어 종류/표준과 관련된 옵션
            - 번외로 C++ Language Options/Objective-C ~ 옵션 등 언어별 특화 속성 옵션이 있음
        - Language Independent Options: 오류 메시지의 출력 포맷 조절 등
        - Warning Options: 각종 경고 메시지를 출력할지 말지 결정
            - 주로 `-Wall`, `-W` 옵션을 사용해 모든 경고 메시지를 출력하도록 컴파일
            - 불필요한 경고가 발생할 시 해당 경고를 끄는 옵션을 이용해 특정 메시지만 제거하도록 사용
        - C-only Warning Options: C언어에만 해당하는 몇 가지 경고 메세지 on/off
        - Debugging Options: 컴파일러 자체 디버깅을 위해 사용하는 옵션
        - Optimization Options: 각종 최적화 관련 옵션
        - Code Generation Options: 인스트럭션을 생성할 규칙을 재정의할 때 사용하는 옵션
    - 어셈블러 옵션: as는 아키텍처마다 각기 다른 어셈블러가 사용되기 때문에 gcc 에서 지원한다기보다는 어셈블러에게 옵션을 바로 넘겨주기 위해 사용
    - 링커 옵션: OS, 부트로더 등과 같은 시스템 프로그램이을 할 때 자주 사용
    - 디렉터리 옵션: 헤더 파일/라이브러리를 찾을 위치 지정 등 각종 디렉토리 지정
    - 기계 종속 옵션: 각종 아키텍처에 종속적인 옵션들

- 옵션 적용 규칙
    1. 각각의 옵션에는 대부분 그에 상응하는 ㅎㅊㅊ내부 변수가 있다
    2. -[f/W/m][옵션]은 설정이고 -[f/W/m]no-[옵션]은 해제다
    3. 동일 종류의 옵션은 최종 옵션만 옵션 변수에 값이 설정된다
    4. 그룹 옵션이 존재한다
    5. -f 는 플래그이고, -W는 경고, -m은 아키텍처 종속, 기타 나머지들
    6. 하나의 옵션이 반드시 하나의 변수만 바꾸는 것은 아니다

#### Reference
- [유닉스 리눅스 프로그래밍 필수 유틸리티]

======================================================
###### 231211 TIL
###### 231212 TIL
###### 231214 TIL
###### 231216 TIL
###### 231218 TIL
###### 231219 TIL
###### 231221 TIL
###### 231223 TIL
###### 240102 TIL