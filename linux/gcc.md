# GCC

## 컴파일
인간이 이해할 수 있는 형식 언어(C,C++ 등) 로 작성된 소스 코드를 CPU가 이해할 수 있는 기계어로 번역하는 과정
- 인스트럭션: CPU 가 이해할 수 있는 이진수로 이루어진 명령
    - 하나의 인스트럭션은 어셈블리 코드와 1대 1 대응
    - `objdump`: 바이너리 파일의 정보를 보여주는 명령어
        - `-S` 옵션: 디버깅 정보 + 인스트럭션 + 어셈블리 코드

### 컴파일 과정
*gcc 컴파일러를 사용
- `/usr/bin/gcc`: 컴파일러 드라이버
    - 실제 컴파일 과정을 처리하는 것이 아니라, 전처리기-C컴파일러-어셈블러-링커, 즉 컴파일 과정에 필요한 명령을 순차적으로 호출해주는 역할
    - 내부 동작
        1. 전처리: `cpp0` 또는 `ccl -E` 명령을 호출
        2. 컴파일: `ccl`
        3. 어셈블: `as` -> 목적 코드
        4. 링크: `collect2` -> 내부적으로 링커인 `ld`를 호출해 라이브러리와 링크 -> 실행 파일 생성
    - 소스 파일의 확장자를 해석해 지원하지 않는 언어이더라도 해당 소스에 맞는 전처리기와 컴파일러를 호출해주기도 함
        - 기본 라이브러리 수동 추가 필요

#### 전처리
`ccl -E` 실행시 동작
0. 입력으로 지정한 소스 파일 읽기
1. 헤더 파일 삽입
    - `/usr/local/include` > `/usr/lib/gcc-lib/.../include` > `/usr/include` 디렉터리 순서로 헤더 파일 탐색 (시스템 헤더 파일)
    - 유닉스 계열 시스템은 `/usr/include` 디렉터리에 헤더 파일들 보관
    - `gcc -I[include dir]` 옵션 사용시 해당 디렉터리 먼저 탐색
    - 헤더 파일을 붙여넣는 중간에 다른 `#include <파일>` 이 나오면 붙여넣기를 중단하고 해당 파일을 찾아서 그 위치에 붙여넣음 > 완료시 재개 
2. 매크로 치환 및 적용
    - `#define`된 부분은 `ccl -E`의 심볼 테이블에 저장
    - 심볼 테이블에 들어있는 문자열과 같은 문자열을 만나면 define 된 내용으로 치환
    - `#ifdef` 와 같이 선택적 매크로도 이 때 처리됨
    - predefine 매크로
        - 소스상에 define 되지 않았지만 전처리기가 임의로 define해주는 매크로
        - `__FILE__`, `__LINE__` 등과 같이 이미 소스 파일 내에 정의된 것
        - 주로 디버깅 출력 메시지에 사용
        - 시스템/컴파일러 종류마다 코드를 구분해 컴파일 할 때도 사용

#### 컴파일
`ccl` 실행시 동작
1. 전단부(front-end): 언어 종속적인 부분 처리
    - 소스 코드가 올바르게 작성되었는지 분석
        1. 어휘 분석: 전처리된 C 코드(.i)를 의미가 있는 가장 최소 단위로 나누기
            - 토큰: 문법적으로 의미 있는 가장 최소 단위의 문자열
                - 지정어(if,while, ..), 연산 기호, 구분자, 명칭(main, printf, ..), 상수
            - 나누어진 토큰은 구문 분석을 담당하는 파서에 넘겨짐
        2. 구문 분석: 프로그램의 문법상 오류 찾기
            - 파스 트리를 만들며 문법적 오류 체크
                - 문법적 오류 발생시 파스 트리가 제대로 생성되지 않음
        3. 의미 분석: 문법상 오류는 없지만 의미상 오류 체크
            - 선언되지 않은 변수, 인자 개수, 자료형 불일치 등
            - 1,2 단계에서 구축된 심볼 테이블 이용
    - 중단부에 넘겨주기 위한 GIMPLE 트리(소스코드를 트리 형태로 표현한 자료 구조) 생성
        4. 중간 표현 생성: 언어 종속적/기계 종속적 부분을 분리해 컴파일러를 모듈화, 최적화를 쉽게 하기 위한 중간 표현 생성
            - GIMPLE 트리: 언어 독립적인 특성을 제공하기 위해 사용하는 트리 형태의 중간 표현
                - 여러 프로그래밍 언어 소스를 공통된 언어 표현으로 바꾼 후 소스 코드를 트리 형태로 표현
                    1. 파스 트리를 언어의 AST(Abstract Syntax Tree)로 변경
                        - *AST: 토큰만으로 이루어진 트리
                        - 파스 트리에서 구문 분석을 위해 실제 코드에는 없는 non-terminal 들을 가지고 있는데, 이러한 불필요한 정보 제거
                    2. AST를 언어 종속적이지 않은 GENERIC 트리로 변경
                    3. Gimplify: GENERIC 트리를 간소화시켜 GIMPLE 트리 생성
            - RTL: 기계 독립적인 특성을 제공하기 위해 사용하는 거의 어셈블리 수준의 중간 표현
2. 중단부: 아키텍처 비종속적인 최적화
    - GIMPLE 트리를 이용해 **아키텍처 비종속적인 최적화** 수행
        1. SSA(Static Single Assignment) 형태 변환
            - 변수에 값을 한 번만 할당하는 중간 표현의 한 가지 형태
            - side effect가 없고, 데이터 흐름이 명시적으로 표현되어 최적화 구현에 용이함
        2. 인터프로시저 분석: 함수 inline 수행, 동적 프로파일링 코드 삽입 등
            * gcov, gprof (프로파일링 분석 툴)
        3. SSA 기반 아키텍처 비종속적인 최적화
            - 최적화: 기능은 동일하나 크기가 작고, 빠르고, 메모리를 적게 사용하도록 코드를 변경하는 작업
            1. 지역 최적화: 공통 부분식 제거, 연산 강도 경감, 상수 계산 등
            2. 전역 최적화: 공통 부분식 제거하고 사용되지 않는 코드 제거
            3. 루프 최적화: 루프 내에서 불변하는 코드 루프 밖으로 조정, 합칠 수 있는 루프는 하나로 합치는 등 조정
            - 최적화 리스트
                - 각종 반환 값 최적화
                - 전체 중복성 제거
                - 조건부 상수 전파
                - 데드 코드 제거
                - 복사 전파
                - value range propagation
                - branch prediction and profiling
                - dead store elimination
    - 후단부에서 사용하는 RTL(Register Transfer Language) 생성
        - RTL: 레지스터 전송 언어; 고급 언어와 어셈블리 언어의 중간 형태
            - 레지스터 레벨의 연산과 오퍼랜드로 표현
            - 특정 아키텍처에 종속적이지 않고 많은 아키텍처를 포용할 수 있게 설계됨
            - RTL 파일: RTL 에서 정의하는 아키텍처의 머신 코드
        1. RTL 코드를 이용해 최적화 과정을 수행
        2. 실제 아키텍처에 맞게 연산자와 메모리 액세스 방식 변경
        3. 가상의 레지스터들을 실제 물리 레지스터에 맵핑
        4. 실제 타켓 머신의 어셈블리 파일로 변환
        
3. 후단부: 목적 코드 생성
    - 아키텍처 비종속적인 최적화 + 아키텍처 종속적인 최적화 수행
        - 아키텍처 종속적인 최적화: 아키텍처의 특성을 타는 최적화;
            - 기계 숙어 변환: 여러 인스트럭션을 아키텍처에서 지원하는 하나의 인스트럭션으로 바꾸는 기법
            - 인스트럭션 스케줄링
            - **레지스터 할당**
                - 무한한 가상 레지스터를 사용하게 작성된 코드를 실제 아키텍처에 있는 제한된 개수의 물리 레지스터를 사용하게 바꾸는 일
                    - RTL을 생성할 때 코드 내 사용된 지역 변수, SSA나 여러 최적화 기법을 통해 생성디는 임시 변수들이 가상 레지스터에 할당됨
                    - 가상 레지스터들이 레지스터 할당을 통해 싪제 물리 레지스터 또는 메모리로 변환
            - 메모리 접근의 최적화
            - 연산 순서 조절
            - 각종 loop 최적화
    - 최적화 완료 후 목적 코드 생성
        - 목적 코드: 타겟 아키텍처의 어셈블리 코드; 이후 어셈블러에 의해 인스트럭션(기계어)으로 변환됨

#### 어셈블
`as` 실행시 동작
- object 파일 생성
    - ELF 바이너리 포맷 구조: 바이너리 파일의 구조를 결정짓는 규약
        - 인스트럭션 + 데이터
        - 바이너리 포맷이 필요한 이유
            1. 링커가 여러 파일들을 링킹할 때, 여러 바이너리가 일정한 규칙을 가지고 있지 않다면 링킹하기 쉽지 않다
            2. 어디까지가 인스트럭션이고, 어디까지가 데이터인지 구분
            3. 링킹 후 실행하더라도 커널 로더(execve() 시스템 콜)가 어떤 식으로 실행해야하는지 알 수 없음
            - 즉, 오브젝트 파일/실행 파일은 그 자체로서 링커/로더에게 정보를 제공해야 하기 때문에 규칙(포맷)을 정해 제공함
        - 유닉스: `a.out`, `ELF`, `COFF` 등
        - 윈도우: `COFF`, `PE 포맷` 등



#### Reference
- [유닉스 리눅스 프로그래밍 필수 유틸리티]

======================================================
###### 231211 TIL
###### 231212 TIL
###### 231214 TIL
###### 231216 TIL
###### 231218 TIL
###### 231219 TIL