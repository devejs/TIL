# GCC

## 컴파일
인간이 이해할 수 있는 형식 언어(C,C++ 등) 로 작성된 소스 코드를 CPU가 이해할 수 있는 기계어로 번역하는 과정
- 인스트럭션: CPU 가 이해할 수 있는 이진수로 이루어진 명령
    - 하나의 인스트럭션은 어셈블리 코드와 1대 1 대응
    - `objdump`: 바이너리 파일의 정보를 보여주는 명령어
        - `-S` 옵션: 디버깅 정보 + 인스트럭션 + 어셈블리 코드

### 컴파일 과정
*gcc 컴파일러를 사용
- `/usr/bin/gcc`: 컴파일러 드라이버
    - 실제 컴파일 과정을 처리하는 것이 아니라, 전처리기-C컴파일러-어셈블러-링커, 즉 컴파일 과정에 필요한 명령을 순차적으로 호출해주는 역할
    - 내부 동작
        1. 전처리: `cpp0` 또는 `ccl -E` 명령을 호출
        2. 컴파일: `ccl`
        3. 어셈블: `as` -> 목적 코드
        4. 링크: `collect2` -> 내부적으로 링커인 `ld`를 호출해 라이브러리와 링크 -> 실행 파일 생성
    - 소스 파일의 확장자를 해석해 지원하지 않는 언어이더라도 해당 소스에 맞는 전처리기와 컴파일러를 호출해주기도 함
        - 기본 라이브러리 수동 추가 필요

#### 전처리
`ccl -E` 실행시 동작
0. 입력으로 지정한 소스 파일 읽기
1. 헤더 파일 삽입
    - `/usr/local/include` > `/usr/lib/gcc-lib/.../include` > `/usr/include` 디렉터리 순서로 헤더 파일 탐색 (시스템 헤더 파일)
    - 유닉스 계열 시스템은 `/usr/include` 디렉터리에 헤더 파일들 보관
    - `gcc -I[include dir]` 옵션 사용시 해당 디렉터리 먼저 탐색
    - 헤더 파일을 붙여넣는 중간에 다른 `#include <파일>` 이 나오면 붙여넣기를 중단하고 해당 파일을 찾아서 그 위치에 붙여넣음 > 완료시 재개 
2. 매크로 치환 및 적용
    - `#define`된 부분은 `ccl -E`의 심볼 테이블에 저장
    - 심볼 테이블에 들어있는 문자열과 같은 문자열을 만나면 define 된 내용으로 치환
    - `#ifdef` 와 같이 선택적 매크로도 이 때 처리됨
    - predefine 매크로
        - 소스상에 define 되지 않았지만 전처리기가 임의로 define해주는 매크로
        - `__FILE__`, `__LINE__` 등과 같이 이미 소스 파일 내에 정의된 것
        - 주로 디버깅 출력 메시지에 사용
        - 시스템/컴파일러 종류마다 코드를 구분해 컴파일 할 때도 사용

#### 컴파일
`ccl` 실행시 동작
1. 전단부(front-end): 언어 종속적인 부분 처리
    - 소스 코드가 올바르게 작성되었는지 분석
        1. 어휘 분석: 전처리된 C 코드(.i)를 의미가 있는 가장 최소 단위로 나누기
            - 토큰: 문법적으로 의미 있는 가장 최소 단위의 문자열
                - 지정어(if,while, ..), 연산 기호, 구분자, 명칭(main, printf, ..), 상수
            - 나누어진 토큰은 구문 분석을 담당하는 파서에 넘겨짐
        2. 구문 분석: 프로그램의 문법상 오류 찾기
            - 파스 트리를 만들며 문법적 오류 체크
                - 문법적 오류 발생시 파스 트리가 제대로 생성되지 않음
        3. 의미 분석: 문법상 오류는 없지만 의미상 오류 체크
            - 선언되지 않은 변수, 인자 개수, 자료형 불일치 등
            - 1,2 단계에서 구축된 심볼 테이블 이용
        4. 중간 표현 생성: 언어 종속적/기계 종속적 부분을 분리해 컴파일러를 모듈화, 최적화를 쉽게 하기 위한 중간 표현 생성
            - GIMPLE 트리: 언어 독립적인 특성을 제공하기 위해 사용하는 트리 형태의 중간 표현
                - 여러 프로그래밍 언어 소스를 공통된 언어 표현으로 바꾼 후 소스 코드를 트리 형태로 표현
                    1. 파스 트리를 언어의 AST(Abstract Syntax Tree)로 변경
                        - *AST: 토큰만으로 이루어진 트리
                        - 파스 트리에서 구문 분석을 위해 실제 코드에는 없는 non-terminal 들을 가지고 있는데, 이러한 불필요한 정보 제거
                    2. AST를 언어 종속적이지 않은 GENERIC 트리로 변경
                    3. Gimplify: GENERIC 트리를 간소화시켜 GIMPLE 트리 생성
            - RTL: 기계 독립적인 특성을 제공하기 위해 사용하는 거의 어셈블리 수준의 중간 표현
    - 중단부에 넘겨주기 위한 GIMPLE 트리(소스코드를 트리 형태로 표현한 자료 구조) 생성
2. 중단부: 아키텍처 비종속적인 최적화
    - GIMPLE 트리를 이용해 **아키텍처 비종속적인 최적화** 수행
    - 후단부에서 사용하는 RTL(Register Transfer Language) 생성
        - RTL: 고급 언어와 어셈블리 언어의 중간 형태
3. 후단부: 목적 코드 생성
    - 아키텍처 비종속적인 최적화 + 아키텍처 종속적인 최적화 수행
        - 인스트럭션 스케줄링, 레지스터 할당 등
    - 최적화 완료 후 목적 코드 생성



#### Reference
- [유닉스 리눅스 프로그래밍 필수 유틸리티]

======================================================
###### 231211 TIL
###### 231212 TIL
###### 231214 TIL